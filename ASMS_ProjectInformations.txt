Eklenen Paketler
Microsoft.EntityFrameworkCore  5.0.14
Microsoft.EntityFrameworkCore.SqlServer  5.0.14
Microsoft.EntityFrameworkCore.Tools  5.0.14
Microsoft.EntityFrameworkCore.Design  5.0.14
Microsoft.AspnetCore.Identity.EntityFrameworkCore 5.0.14

Auto Mapper 9.0.0 
AutoMapper.Extensions.Microsoft.DependencyInjection 7.0.0









Proje Detaylarý

ViewModels'e UsersAddressVM ekledik bunu entity katmanýna eklememizin sebebi her taraftan eriþilsin diye.
Normalde viewmodel oluþtururken UI katmanýna ekliyoduk sadece ekranda göstermek istediðimizde UI katmanýna ekliyoruz.
Bu projede oluþturdugumuz örnek olarak UsersAddressVM sadece ekranda göstermek için oluþturmuyoruz ayrýca bunu veritabanýna yazmak için kullanýcaz.
Yani hem UI hem Bll Hemde Dal katmaný kullanýcak ViewModeli. 

Auto Mapper 9.0.0 
AutoMapper.Extensions.Microsoft.DependencyInjection 7.0.0 kütüphanelerini projeye dahil ettik çünkü UsersAddress ve UsersAddressVM birbirleriyle eþleþtirmek için bunlarý yapýyoruz.
tek tek elimizde DTO larda yaptýgýmýz gibi örnek name=x.name falan yapýyoduk. bunlarý otomatikmen Auto Mapper kendisi yapýyor. Hani class için ve hangi ViewModel için yapcagýmýzý
projeye söylüyoruz.  

Bu iþlem için Maps classý oluþturduk ve onu profile dan kalýtým aldýk --> Maps : Profile bu þekilde 

Bu Maps sýnýfýnda constructorunda aþagýdaki iþlemleri yapýyoruz.

//UserAddress ve VM'yi birbirine dönüþtür --> CreateMap<UsersAddress, UsersAddressVM>().ReverseMap(); yapýyoruz.
ReverseMap() yapmamýzýn amacý aþagýdaki iþlemi tek seferde yapmasýdýr.
//UserAddress'ý UsersAddressesVm'ye dönüþtür
            //CreateMap<UsersAddress, UsersAddressVM>();   //DAL--> BLL

            //UsersAddressVm'ý UserAddress'ye dönüþtür
            //CreateMap<UsersAddressVM, UsersAddress>();   //PL-->BLL-->DAL

Bu iþlemlerden sonra STARTUP ' ta  Mapleme iþlemi yaptýgýmýzý bildiriyoruz. STARTUP'ta ConfigureServices içine yapýyoruz bu iþlemi 
//Mapleme eklendi.
services.AddAutoMapper(typeof(Maps));

Bu aþamadan sonra IResult yapýsýný projeye dahil ettik bunu yapmamýzýn amacý projeye ürün eklerken baþarýlý mý baþarýsýz mý bi deðer dönsün diye bunlarý yapýyoruz.
Business katmanýnda serviceler ve manager kýsýmlarýnda CRUD iþlemleri yapýlmaya baþlandý. 

var cities = _unitofWork.CityRepo.GetAll(x => !x.IsDeleted, includeEntities: "Districts"); (includeEntities: "Districts" --> bu iþlem ile join iþlemi yapýlýyor.)
ICollection<CityVM> allCities = _mapper.Map<IQueryable<City>, ICollection<CityVM>>(cities);
Bu iþlem CityGetAll için yazýldý. 

Business katmanýnda serviceler ve manager kýsýmlarý oluþturuldu.
Mail göndermek iþlemi yapmak için EmailMessage classý oluþturulduk. IEmailSender oluþturuldu. IEmailSender da Task SendMessage(); oluþturuldu. 
Task olmasýnýn sebebi asenkron þeklinde tanýmlýyoruz.


EmailSender a aþagýdaki propertyleri ekledik.
public string SenderMail => _configuration.GetSection("EmailOptions:SenderMail").Value;
        public string Password => _configuration.GetSection("EmailOptions:Password").Value;
        public string Smtp => _configuration.GetSection("EmailOptions:Smtp").Value;
        public int SmtpPort => Convert.ToInt32(_configuration.GetSection("EmailOptions:SmtpPort").Value);

        bu propertyleri aþagýdaki bilgilerle almýþ oluyoruz. ve bunlarý sendmessage içinde dolduruyoruz.

EmailSender'a private readonly IConfiguration _configuration; ekledik. çünkü appsettings' e 
 
 "EmailOptions": {
    "SenderMail": "303asms@gmail.com",
    "Password": "ezgi was here",
    "Smtp": "smtp.gmail.com",
    "SmtpPort": "587"
  },
  "ProjectManagers": {
    "Email": "betulaksan1992@gmail.com"

  }

  bunlarý ekledik ve EmailSender içindeki SendMessage içinde _configuration metoduyla burdaki bilgileri çekebileceðiz.
  SendMessage içinde mail iþlemlerini yaptýk.

 IStudentBusinessEngine ve StudentBusinessEngine projeye dahil ettik. Bu serviceler için StudentVm oluþturduk.
 çünkü ilerde ekranda Studentle alakalý bilgiler  görmek isteyeceðimiz durumda bu ViewModelden bu bilgileri almýþ olucaz.
 Bu StudentBusinesEngine yani manager kýsmýndada  da mapper iþlemi yapýyoruz. Bu iþlem bize gelen iþlemleri otomatik olarak yapmamýzý saðlýyor.
 Mesela name=studen.name gibi iþlemleri biz yapýyoduk þimdi mapper yapýyor.
 

 RegisterViewModel oluþturduk bunu oluþturmamýzýn sebebi UI Katmaný Business katmanýný görüyor.
 Biz Repolarýmýzý DataAccess katmanýnda yaptýgýmýz için ordaki verilere ulaþamýyoruz. 
 Bu sebepten dolayý Controllarda herþeyi ViewModeller üzerinden yapýyoruz. 
 Repolarýmýz Business katmanýnda olsaydý ViewModeller üzerinden deðil direk Entityler üzerinde gidicektik.

 Bu RegisterViewModel kullanarak Register iþlemi için public async Task<IActionResult> Register(RegisterViewModel model) yapýyoruz. 
 Async yapmamýzýn sebebi asenkron olmasýný istediðimiz için.

Login iþlemi yapýldý.
login iþlemi için loginviewmodel oluþturuldu.LoginViewModel' e bize lazým olan propertyler yazýldý ve Login iþleminin post kýsmýnda bu view modele göre yapýyoruz.


Projenin Headeriný ve footer kýsmýný partial olarak aldýk ve layoutda partial çagýrdýk.
Core da partial yerine ViewComponent yapýsý geldi. 
PartialView yapýlanmasý ihtiyacý olan datalarý Controller üzerinden elde edeceði için Controllerdaki maliyeti artýrýr ve solid prensiblerine aykýrý davranýr.

PartialView yapýsal olarak controller üzerinden beslenmektedir.

ViewComponent ihtiyacý olan datalarý controller üzerinden deðilde direkt kendi cs dosyasýndan elde etmektedir.

UI katmanýnda Views içinde _ViewImports.cshtml dosyasýnda projede kullanýlan tüm usingler ve taghelperlarý ekliyoruz

Rol atama iþlemi için CreateData oluþturuldu. Proje ayaga kalktýgý zaman veritabanýna rolleri atýyacak.

CreateData classý içinde static olarak Create metodu oluþturuldu. Parametreleri ( RoleManager<AppRole> roleManager ).
Bu metod içerinde  CheckAndCreateRoles( bu metod aþagýda oluþturuluyor.) metoduda  CheckAndCreateRoles(roleManager) þeklinde ekledik.
Static olarak  metodu oluþturuldu. CheckAndCreateRoles(RoleManager<AppRole> roleManager) roleManager parametresi alýyor.

CheckAndCreateRoles metodunda  
var allRoles = Enum.GetNames(typeof(ASMSRoles)); diyerek Enumlardan rolleri çekiyoruz.
foreach (var item in allRoles) ile rolleri geziyoruz.
 if (!roleManager.RoleExistsAsync(item).Result) veritabanýnda bu roller var mý diye bakýyoruz.
 ! iþareti koydugumuz için yoksa if bloguna girecek

 AppRole role = new AppRole()
                    {
                        Name = item,
                        IsDeleted = false,
                        CreatedDate=DateTime.Now,
                        Description=$"Sistem tarafýndan {item} rolü ektedir."
                    };
bu þekilde rollerimizi atýyoruz.

var result = roleManager.CreateAsync(role).Result;  ile kaydediyoruz.

Asenkron iþlem yaptýgýmýz için roleManager.CreateAsync(role).
Result sonuna result yapmamýz lazým rol atamasý yaparken bu iþlemleri hepsini yapana kadar bekle diyoruz. 
Result eklediðimiz zaman asenkron olmadan çýkýyo senkron oluyo bu sayede bu iþlemleri yapýyo sonra diger iþlemlere geçiyor. 
Asenkron oldugu zaman arka tarafta bu iþlemleri yaparken çakýþýyo çünkü asenkron oldugu zaman baþka iþlemler de yapýlýyor.

AddAddress e @section Scripts ekledik. Buralarý yazma amacýmýz il seçtiðimiz anda sayfa yenilenmeden ilçeler gelsin.
JQuery ve Ajax iþlemleri yapýldý.
Bu yaptýklarýmýzý _LayoutASMS nin en altýnda @RenderSection("Scripts", required: false) þeklinde çagýrdýk.

DistrictController oluþturduk. Bu Controllerda 
private readonly IDistrictBusinessEngine _districtEngine;  

public JsonResult GetCityDistricts(byte cityId)  metodu oluþturduk.
var data = _districtEngine.GetDistrictsOfCity(cityId).Data; try catch oluþturduk. try kýsmýnda return Json(new { isSuccess = true, data });
Bu þekilde veriyi döndürdük.
catch kýsmýnda return Json(new { isSuccess = false }); bu þekilde dönüþ yapýldý.
